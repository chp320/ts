# 개발자에서 아키텍트로
- 책을 읽고 개인적으로 정리한 내용

## 들어가기 전에
- SWA는 모든 '이해관계자'와 협업하면서 비즈니스 목표와 요구사항을 만들어 감
- 통상 PM은 '기능(feature)'을 정의하지만 SWA는 이에 더불어 '품질 속성'을 또하나의 요구사항으로 만드는 일을 함
- 트레이드오프: 개발 시 하나를 포기하면 그 대신 하나를 얻는 상황을 의미
  - SWA는 항상 기능과 품질 사이에서 트레이드오프를 고려해야 함
- 기술부채(technical debt): 소프트웨어 시스템의 현재 설계와 소프트웨어가 지속적으로 가치를 창출하기 위해 가져야만 하는 바람직한 설계 사이의 간극
  - SWA는 기술부채를 시각화하고 이해관계자에게 이를 어떻게 관리해야하는지 support해야 함

## 1. 디자인 싱킹 (design thinking)
- 어려운 일을 할 때 도움되는 방법으로 문제와 해결책, 이에 영향 받는 사람들의 관점에 대해 생각하는 방식
- 디자인 싱킹의 네가지 원칙
  - 인간중심의 원칙(human rule) : 모든 디자인은 사회적이다
  - 모호함의 원칙(ambiguity rule) : 모호함을 유지하라
  - 재디자인의 원칙(redisign rule) : 모든 디자인은 다시 디자인(redisign)한 것이다.
  - 촉각의 원칙(tangibility rule) : 손에 잡히는 디자인이 대화를 이끌어 낸다.

### (디자인 싱킹) 모든 디자인은 사회적이다
- 아키텍트는 모든 이해관계자들과 공감대를 형성해야 한다. (개발자, 테스터, 매니저 등)
- 아키텍트는 팀원들과 직접 소통하면서 함께 설계해야 한다.

### (디자인 싱킹) 모호함을 유지하라
- 설계를 확정하기 전까지는 당분간 모호하게 놔두는 방법을 쓴다.
- 소프트웨어 아키텍처의 목적은 품질 속성을 끌어올릴 수 있도록 여러 구조를 정리하는 것이다.
- 최소한의 아키텍처(루스 말란, 다나 브레데마이어)는 달성해야 하는 가장 중요도 높은 품질 속성만 제시해 이 품질 속성을 방해하는 위험 요소는 줄이고, 그 외에 설계에 대한 모든 의사결정은 하위 설계자들이 알아서 결정하게 한다는 것이다.
- 즉, 책임있는 범위만큼만 설계에 대한 의사결정을 하고 품질 속성에 직접 영향을 미치지 않거나 납기를 맞추지 못하는 위험은 설계상의 세부사항으로 둔다는 것이다.

### (디자인 싱킹) 모든 디자인은 다시 디자인한 것이다
- '다시 디자인한다'는 의미는 과거의 디자인에서 패턴을 찾고 고찰해 보는 것이다.
- 소프트웨어 아키텍처를 설계할 때 바닥부터 새로 만들기 보다 과거 누군가 이미 겪고 문서화한 내용을 기반으로 설계 시작 가능하다.
- <패턴 랭귀지(크리스토퍼 알렉산더, 인사이트)>에서 253개의 도시공학 문제와 해결책을 정리하였는데, 이와 마찬가지로 아키텍처 설계 시 과거 내용을 패턴화하고 정리할 수 있다.

### (디자인 싱킹) 손에 잡히는 디자인이 대화를 이끌어낸다
- 그림으로 그리고 코드로 구현해서 프로토타입으로 사람들이 직접 경험할 수 있게 하자.

<hr />

## 2. 디자인 마인드셋 (design mindset)
- 소프트웨어 설계 시 '여러 관점'을 통해 분석/진행 가능
- 네 가지 '디자인 마인드셋' (무엇을 먼저 적용하든 순서 무관)
  - 문제 이해하기 : 이해관계자들이 중요하게 생각하는 비즈니스 목표와 품질 속성 조사가 필요하고, 트레이드오프와 우선순위 결정이 필요하다.
  - 아이디어 탐색하기 : 여러 구조를 조합하다가 '품질 속성'을 최대한으로 끌어올릴 최선의 조합을 찾는 것이다. '최선의 조합'을 찾기 위해서는 다양한 패턴, 기술, 구현 방법에 대해 조사해야하고 많은 시간을 할애해야 한다. 브레인스토밍과 포스트잇 활용 추천.
  - 실현하기 : 설계 컨셉을 프로토타입 등으로 현실 세계의 '실체'로 만든다.
  - 평가하기 : 결과물이 요구사항을 충족하는지 등을 검사하는 단계이다.
```
이해하기 - 이해관계자들이 필요로 하는 바를 요구사항으로 구체화하는 방법에 집중
탐색하기 - 문제를 패턴, 기술 등 여러 수단으로 파악해본 후 해결 방법을 브레인스토밍
실현하기 - 시스템을 모델링해 구체적인 결과물을 공유
평가하기 - 결과물이 요구사항에 맞는지 테스트
```
- '디자인 마인드셋' 적용 시마다 생각-실행-확인 세 단계로 반복해보자.
<img src="https://github.com/chp320/ts/assets/47440517/f92f1208-4322-4618-8e7a-fb3692c29965" width="60%" height="50%" />

<hr />

## 3. 설계 전략 고안하기
- 소프트웨어 아키텍처는 최적의 방법을 찾는 문제 풀이보다는 아래와 같은 활동을 통해 만족스러운 설계를 찾아가는 과정
  - 실험으로 해결하기 : 가설을 빠르게 평가하고 만족할 구조로 빨리 조합 가능
  - 위험 요소 줄이기
  - 문제 단순화하기
  - 빠르게 반복하고 빠르게 배우기 : 빠른 실패는 빠른 학습을 의미. 짧고 촘촘한 일정으로 반복 경험하자
  - 문제와 해결책을 동시에 생각하기 : 문제를 이해하려면 주변을 탐험해야 한다. 소프트웨어 아키텍처 설계는 문제 파악과 동시에 해결책도 생각해야 하는 일이다.
  - 아키텍처 설계는 중요하지만 설계에 시간을 많이 소비하면 구현에 쓸 시간이 부족하고, 설계에 시간이 부족하면 개발하면서 계속 아키텍처 수정이 불가피하다. 시스템마다 요구사항과 규모에 맞는 "설계 최적점"이 있다.

### 설계 최적점 찾기
- 전체 프로젝트 시간 = 개발 시간 + 아키텍처 설계 및 위험 제거 시간 + 재작업 시간 (배리 베임)
  - 재작업: 설계 결함을 수정하거나 코드 재작성, 원복 등을 의미
  - 최적점은 '설계' 시간과 '재작업' 시간 사이 어딘가에서 찾아야 한다.
- 설계와 재작업에 들어가는 시간 상관 관계
  - 소프트웨어 시스템의 규모와 최적점의 상관관계를 나타낸다. (1KSLOC는 소스 코드 1,000줄을 의미)
<img src="https://github.com/chp320/ts/assets/47440517/db520095-1352-443b-8f56-a5eb03d111bc" width="60%" height="50%" />

  - 시스템의 규모가 클수록 초기 설계에 투자하는 데서 얻는 이득이 커진다.
  - 시스템의 규모가 작으면 초기 설계에 투자하는 데서 얻는 이득이 작아진다.
  - 즉, 설계에 많은 시간을 들이기 보다는 코드 재작성이 낫다는 것. but 초기 설계를 무시하면 재작업이 필수임.
  - 아키텍처 설계에 거의 투자하지 않으면 큰 타격을 받을 수 있다.
```
설계에 시간의 5%를 할애할 경우 전체 개발 일정은 43% 증가
설계에 시간의 17%를 할애할 경우 전체 개발 일정은 38% 증가
```
예시) 개발 기간을 100일로 정할 때 예측 수치
<table>
<tr><th>설계 소요일</th><th>재작업 소요일</th><th>프로젝트 소요일</th></tr>
<tr><td>5</td><td>38</td><td>143</td></tr>
<tr><td>17</td><td>21</td><td>138</td></tr>
<tr><td>33</td><td>7</td><td>140</td></tr>
</table>
⚠️ 설계에 시간을 무작정 많이 할애한다고 일정이 줄어들지 않음

<hr />

### 위험 요소를 가이드 삼기
- 위험 요소를 파악한다면 설계 작업에 언제 착수하고 무엇을 설계할지, 이해관계자들과 어떻게 참여해야할 지 알 수 있다.
- 위험 요소 파악하기
  - 소프트웨어를 만들 때 걱정되는 사항을 모두 나열하자
  - 심각한 문제를 초래하는 순서대로 정렬하자
  - 상위의 위험 요소 하나를 선택하고 이를 해소할 수 있는 '디자인 마인드셋'(이해하기/탐색하기/실현하기/평가하기)을 고르자
 
#### (위험 요소 파악하기) 조건과 결과 알아내기
- '위험': 미래에 일어날 수도 있는 나쁜 일에 대한 암시이며, 나쁜 일이 실제 일어나면 '위험'이 아니라 '문제'가 된다.
- 위험은 조건(현재의 사실)과 결과(아마도 일어날 수 있는 나쁜 일) 로 나누어진다.
- 위험 구문 기록 시, <조건> - <결과> 의 형태로 작성해보자
```
예시) 사무실 맞은편에 부리토 음식점이 생겼다 - 동료가 부리토를 너무 많이 먹으면 복통을 앓을 수 있다
* 위험을 줄이는 방법
- 확률 낮추기: 며칠에 한 번마다 음식 배달을 하고 한 사람이 먹을 수 있는 최대 섭취량을 안내한다.
- 영향 낮추기: 사무실에 소화제를 비치한다.
- 위험이 발생할 시간 없애기: 점심 시간에 미팅을 만들어서 저녁에만 부리토를 먹도록 한다.
- 조건 없애기: 사무실을 이사한다. 또는 근무시간을 변경해서 음식점 닫은 시간에만 일하도록 한다.
- 아무것도 하지 않기: 문제가 실제로 일어나면 대처한다.
```

#### (위험 요소 파악하기) 위험을 활용해 적절한 디자인 마인드셋 선택하기
<table>
  <tr><th>적용할 디자인 마인드셋</th><th>만약에...</th></tr>
  <tr><td>이해하기</td><td><b>문제 정의가</b> 위험 요소인 경우입니다. 이해관계자나 연관된 시스템에 대해 더 깊게 이해할 필요가 있나요?</td></tr>
  <tr><td>탐색하기</td><td><b>해결 방법</b>이 위험 요소인 경우입니다. 다른 대안은 없나요?</td></tr>
  <tr><td>실현하기</td><td><b>커뮤니케이션</b>이 위험 요소인 경우입니다. 이해관계자들이 설계를 충분히 이해했고 설계도를 볼 수 있나요?</td></tr>
  <tr><td>평가하기</td><td><b>설계의 의사결정이나 설계의 전반적인 적합성</b>이 위험 요소인 경우입니다. 설계에 대한 의사결정을 해야 하나요?</td></tr>
</table>

#### (위험 요소 파악하기) 위험이 줄면 수동적인 설계로 전환한다
- 아키텍처가 더는 시스템에서 가장 큰 위험요소가 아니라면, 구현된 아키텍처를 관찰하고 필요에 따라 수정 조치를 취하는 '수동적인 설계'로 진행한다.

### 설계 계획을 세울 때 몇 가지 개념을 가지고 접근 필요하다
- 설계의 판단 근거 : 작은 부분부터 구현? 시간이 걸려도 위험을 줄이는 설계를 할까? 여러 영역을 동시에?
- 디자인 산출물 : 화이트보드 사진? 문서화? 특정 템플릿? 결과물 저장은?
- 일정 : 설계 마일스톤 필요. 주요 오구사항을 검토, 초안 설계 검토, 평가 수행하는 마일스톤 포함. 이해관계자와 워크샵 등
- 위험 요소 : 주요 위험 요소를 설계 계획에서 핸들링
- 개괄적인 아키텍처 디자인 : 초기 구상한 대략적인 설계를 논할 수 있을 정도의 가벼운 디자인

<hr />

## 4. 이해관계자와 공감하기 (마인드셋-이해하기)
- 이해관계자(stakeholder): 어떤 소프트웨어에 관심이 있거나 관여된 사람
- 일반적으로 이해관계자는 한 명이 아니기 때문에 '이해관계자 그룹(stakeholder group)' 이라 칭하기도 함

### 이해관계자 맵 만들기
- 이해관계자 맵 : 소프트웨어 시스템에 관여하거나 영향받는 모든 사람을 보여주는 네트워크 다이어그램
- 아래는 '이해관계자 맵' 예시
<img src="https://github.com/chp320/ts/assets/47440517/ef1685c9-6161-449c-b633-ecc7cd8d39e9" width="60%" height="50%" />

### 비즈니스 목표 탐색하기
- 비즈니스 목표(business goal)는 이해관계자가 소프트웨어를 통해 달성하고 싶은 것이 무엇인지 설명가능한 문장으로 '아주 단순하게' 정의되어야 함
- 비즈니스 목표는 주체/결과/맥락의 세 가지 항목을 다루어야 함
  - 주체: 구체적인 사람 또는 역할
  - 결과: 이해관계자들의 요구를 측정 가능한 결과로 표현. 
  - 맥락: 이해관계자들의 필요를 더 잘 이해하고 공감대를 형성할 수 있게 상세한 내용을 기재.
  - 예) <주체(이해관계자)>xx 시장</주체(이해관계자)>은 <결과(이해관계자의 요구)>조달 비용을 30% 줄이고 싶어</결과(이해관계자의 요구)>한다. <맥락>필수 서비스의 예산을 깍고 싶지 않기 때문이다.</맥락>

<hr />

## 5. 아키텍처 핵심 요구사항 알아내기 (마인드셋-이해하기)
- 모든 아키텍처 설계는 누가, 무엇을, 왜 하는지 논의하는 일에서 시작한다.
- 이해관계자를 중심에 두고 누가 영향을 미치는지 알아봤다면, 소프트웨어 아키텍처 관점에서 '무엇을'에 해당하는 '요구사항'을 어떻게 다루는지 고민해보자
- 네 가지 '요구사항' 속성
  - 제약: 바꿀수 없는 결정사항
  - 품질 속성: 다른 시스템과 구분짓는 겉으로 보이는 요소. 구체적인 상황에서 시스템이 어떤 작업을 수행하는지 등
  - 영향력 있는 기능 요구사항: 특별히 주목해야 하는 기능
  - 기타: 시간, 지식, 경험 등 설계에 영향을 미치는 요소들
 
### '제약'으로 설계 선택지 줄이기
- 제약은 이미 정해져서 '변경이 불가능한' 설계상의 의사결정을 의미
- 기술적인 제약과 비즈니스적인 제약으로 나눌 수 있음
  - 기술적인 제약: 소프트웨어 시스템 개발 시 사용 가능한 기술에 대한 결정을 제한
  - 비즈니스적인 제약: 인력, 프로세스, 비용, 일정 등에 대한 결정을 제한
  - 아래는 제약에 대한 예시
<table>
  <tr><th>기술적인 제약</th><th>비즈니스적인 제약</th></tr>
  <tr><td>개발언어: JVM 기반이면 뭐든 상관없음</td><td>팀 구성: 팀 A가 컴포넌트 X를 만들 것이다</td></tr>
  <tr><td>OS,플랫폼: 윈도우,리눅스,BeOS에서 구동되어야 함</td><td>일정,예산: 7월 전시회 출품해야 하고 개발비는 80억원을 넘으면 안됨</td></tr>
  <tr><td>사용 가능한 컴포넌트: DB2를 가지고 있으므로 이를 활용해야 함</td><td>법률,계약: 구매한 라이선스 하루 데이터 처리량은 최대 5GB로 제한</td></tr>
</table> 

#### 제약 단순화하기
- 간단한 문장으로 설계 결정과 그 주체를 설명하면, 제약 파악에 보다 용이함













```
```
